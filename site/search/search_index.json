{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PoolFlow","text":"<p> <p>A simple process management library</p> <p></p>"},{"location":"#introduction","title":"Introduction","text":"<p>PoolFlow provides simple objects to manage the execution of a variety of tasks and  its memory usage. The main objective of PoolFlow is to perform a lot of scientific calculations  and manage their successive executions through the subprocess library.</p>"},{"location":"#schematic-principle","title":"Schematic principle","text":"<p>The way PoolFlow works could be synthesized by the following diagram. A list of jobs is  given and the <code>pool</code> object manage the available virtual memory, considering the maximum estimated cost of the job given by the user.</p> <p> <p><pre><code>graph LR\nA[Job with&lt;br&gt;given cost]--&gt;|Set of parameters|B{Pool};\nB--&gt;C[Estimated usage&lt;br&gt;memory];\nC--&gt;|Not enough&lt;br&gt;memory|B;\nC--&gt;|Memory available&lt;br&gt;and allocated|D[Job is&lt;br&gt;launched];\nD--&gt;|Job is done&lt;br&gt;memory est released|B;\n</code></pre> </p>"},{"location":"#installing","title":"Installing","text":"<p>The only external package SourceFlow depends on is <code>rich</code>. Install it directly via <code>pip</code>:</p> <p> <p><code>pip install PoolFlow</code></p> <p></p>"},{"location":"#warning-and-known-issues","title":"Warning and known issues","text":"<p>PoolFlow uses management resources via <code>resource</code> native package. Due to the way <code>resource</code> work, some limitation and unlimitation procedures are only available on Unix.</p>"},{"location":"dynamicpool/","title":"DynamicPool","text":"<p>         Bases: <code>Thread</code></p> <p>Creates a pool to submit job and manage tasks based on their estimated costs. Pool ends only when user call.</p> <p>Examples:</p> <p>Setting up the pool</p> <pre><code>&gt;&gt;&gt; import PoolFlow as pf\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; pool = pf.DynamicPool(override_max_value=50) # Maximum value of 50 Go of virtual memory available\n</code></pre> <p>Definition of the job functions</p> <pre><code>&gt;&gt;&gt; def test_func(sec): # Making a dummy function example\n&gt;&gt;&gt;     os.system('pythonw')\n&gt;&gt;&gt;     time.sleep(sec)\n</code></pre> <p>Launching pool, adding jobs and waiting for them to end and getting a review of it</p> <pre><code>&gt;&gt;&gt; pool.start() # Starting the pool\n&gt;&gt;&gt; for i in range(1,5):\n&gt;&gt;&gt;     pool.submit(test_func, (i,), 20) # Giving jobs to the pool with a cost of 20 Go each\n&gt;&gt;&gt; pool.end() # Wait for all the jobs to terminate\n&gt;&gt;&gt; pool.review() # Synthesize the pool session\n                                                                                                   Pool Review\n                                                                                           Started - 08/09/22-10:30:24\n                                                                                            Ended - 08/09/22-10:30:35\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Thread Id \u2503 Thread Status \u2503 Memory Status \u2503 Cost (Go) \u2503 Target    \u2503 Parameters \u2503 Start Date        \u2503 End Date          \u2503 Running Time (h) \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 1         \u2502 Dead          \u2502 Released      \u2502 20        \u2502 test_func \u2502 (1,)       \u2502 08/09/22-10:30:25 \u2502 08/09/22-10:30:27 \u2502 0.0              \u2502\n\u2502 3         \u2502 Dead          \u2502 Released      \u2502 20        \u2502 test_func \u2502 (3,)       \u2502 08/09/22-10:30:25 \u2502 08/09/22-10:30:29 \u2502 0.0              \u2502\n\u2502 2         \u2502 Dead          \u2502 Released      \u2502 20        \u2502 test_func \u2502 (2,)       \u2502 08/09/22-10:30:27 \u2502 08/09/22-10:30:30 \u2502 0.0              \u2502\n\u2502 4         \u2502 Dead          \u2502 Released      \u2502 20        \u2502 test_func \u2502 (4,)       \u2502 08/09/22-10:30:29 \u2502 08/09/22-10:30:34 \u2502 0.0              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Attributes:</p> Name Type Description <code>init_memory</code> <code>int</code> <p>Memory available at the creation of the pool. It can be overrided with override_max_value</p> <code>memory</code> <code>int</code> <p>Memory available at the moment</p> <code>output</code> <code>str or None</code> <p>The file to write the output. If none, will write on the console. (default is None)</p> <code>pool</code> <code>list</code> <p>A list of jobs to be executed</p> <code>launched</code> <code>list</code> <p>A list of jobs that have been launched</p> <code>idle_time</code> <code>int</code> <p>The time in seconds between each verification by the system of the current resources allocations (default is 1)</p> <code>refresh_time</code> <code>int</code> <p>The time in seconds between each status emission by the pool (default is 5)</p> <code>is_over</code> <code>bool</code> <p>If True, the pool is terminated</p> <code>count</code> <code>int</code> <p>The number of jobs submitted</p> <code>start_date</code> <code>datetime object</code> <p>The date at which the pool has been created</p> <code>end_date</code> <code>datetime object</code> <p>The date at which the pool has been terminated</p> <p>Parameters:</p> Name Type Description Default <code>idle_time</code> <code>int, optional</code> <p>The time in seconds between each verification by the system of the current resources allocations (default is 1)</p> <code>1</code> <code>refresh_time</code> <code>int, optional</code> <p>The time in seconds between each status emission by the pool (default is 5)</p> <code>5</code> <code>override_max_value</code> <code>int or None, optional</code> <p>The maximum virtual memory available in the system/for the pool. If None, will get the maximum from the OS (default is None)</p> <code>None</code> <code>output</code> <code>str or None, optional</code> <p>The file to write the output. If none, will write on the console. (default is None)</p> <code>None</code> <code>external</code> <code>bool, optional</code> <p>If True, will replace command by external python files to run. (default is False)</p> <code>False</code> Source code in <code>PoolFlow\\dynamic_pool.py</code> <pre><code>def __init__(self, idle_time=1, refresh_time=5, override_max_value=None, output=None, external=False):\n\"\"\"\n    Parameters\n    ----------\n    idle_time : int, optional\n        The time in seconds between each verification by the system of the current resources allocations\n        (default is 1)\n    refresh_time : int, optional\n        The time in seconds between each status emission by the pool (default is 5)\n    override_max_value : int or None, optional\n        The maximum virtual memory available in the system/for the pool. If None, will get the maximum from the OS\n        (default is None)\n    output : str or None, optional\n        The file to write the output. If none, will write on the console. (default is None)\n    external : bool, optional\n        If True, will replace command by external python files to run. (default is False)\n    \"\"\"\n    super(DynamicPool, self).__init__()\n    self.status = None\n    if not override_max_value:\n        self.init_memory = round(mem().available / 1E9, 0)\n    else:\n        self.init_memory = override_max_value\n    self.output = output\n    self.external = external\n    self.memory = self.init_memory\n    self.pool = []\n    self.launched = []\n    self.idle_time = idle_time\n    self.refresh_time = refresh_time\n    self.is_over = False\n    self.count = 1\n    self.start_date = datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")\n    self.end_date = \"\"\n    if self.output:\n        self.csl = Console(file=open(self.output, 'w'))\n    else:\n        self.csl = Console()\n</code></pre>"},{"location":"dynamicpool/#PoolFlow.dynamic_pool.DynamicPool.runnings","title":"<code>runnings</code>  <code>property</code>","text":"<p>Returns a list with running jobs</p>"},{"location":"dynamicpool/#PoolFlow.dynamic_pool.DynamicPool.deads","title":"<code>deads</code>  <code>property</code>","text":"<p>Returns a list of dead jobs</p>"},{"location":"dynamicpool/#PoolFlow.dynamic_pool.DynamicPool.submit","title":"<code>submit(target, args, cost, pre_processing=None, post_processing=None)</code>","text":"<p>Submit a new task to perform the pool</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>fun</code> <p>A function containing the task</p> required <code>args</code> <code>tuple</code> <p>The arguments to be parsed in the function</p> required <code>cost</code> <code>int</code> <p>The cost of the job in giga octets</p> required <code>pre_processing</code> <code>tuple, optional</code> <p>A preprocessing function to be called before the running part. Preprocessing cost is assumed to be negligible comparing to the job. Preprocessing function are executed before jobs executions and even if no virtual memory is available. Preprocessing tuple are given as following: (function, (tuple,with,arguments)) If None, no preprocessing will be executed. (default is None)</p> <code>None</code> <code>post_processing</code> <code>tuple, optional</code> <p>A postprocessing function to be called after the running part. Postprocessing cost is assumed to be negligible comparing to the job. Postprocessing function are executed after jobs executions and memory release. Postprocessing tuple are given as following: (function, (tuple,with,arguments)) If None, no postprocessing will be executed. (default is None)</p> <code>None</code> Source code in <code>PoolFlow\\dynamic_pool.py</code> <pre><code>def submit(self, target, args, cost, pre_processing=None, post_processing=None):\n\"\"\"\n    Submit a new task to perform the pool\n\n    Parameters\n    ----------\n    target : fun\n        A function containing the task\n    args : tuple\n        The arguments to be parsed in the function\n    cost : int\n        The cost of the job in giga octets\n    pre_processing : tuple, optional\n        A preprocessing function to be called before the running part. Preprocessing cost is assumed to be\n        negligible comparing to the job. Preprocessing function are executed before jobs executions and even if no\n        virtual memory is available. Preprocessing tuple are given as following: (function, (tuple,with,arguments))\n        If None, no preprocessing will be executed. (default is None)\n    post_processing : tuple, optional\n        A postprocessing function to be called after the running part. Postprocessing cost is assumed to be\n        negligible comparing to the job. Postprocessing function are executed after jobs executions and\n        memory release. Postprocessing tuple are given as following: (function, (tuple,with,arguments))\n        If None, no postprocessing will be executed. (default is None)\n    \"\"\"\n    if self.external:\n        self.pool.append(Calculation(RawExternalCmd, (args,), cost, self.count, pre_processing, post_processing))\n    else:\n        self.pool.append(Calculation(target, args, cost, self.count, pre_processing, post_processing))\n    self.count += 1\n</code></pre>"},{"location":"dynamicpool/#PoolFlow.dynamic_pool.DynamicPool.empty","title":"<code>empty()</code>","text":"<p>Empty the pool of jobs</p> Source code in <code>PoolFlow\\dynamic_pool.py</code> <pre><code>def empty(self):\n\"\"\"\n    Empty the pool of jobs\n    \"\"\"\n    self.pool = []\n</code></pre>"},{"location":"dynamicpool/#PoolFlow.dynamic_pool.DynamicPool.end","title":"<code>end(now=False)</code>","text":"<p>Ends the pool and wait for it to be dead.</p> <p>Parameters:</p> Name Type Description Default <code>now</code> <code>bool, optional</code> <p>If True, forces the jobs to end (default is False)</p> <code>False</code> Source code in <code>PoolFlow\\dynamic_pool.py</code> <pre><code>def end(self, now=False):\n\"\"\"\n    Ends the pool and wait for it to be dead.\n\n    Parameters\n    ----------\n    now : bool, optional\n        If True, forces the jobs to end (default is False)\n    \"\"\"\n    if now:\n        if not self.pool:\n            self.csl.print('[red]Cannot end pool - Threads are still awaiting. Force with empty method')\n    else:\n        if not now:\n            while self.pool or self.runnings:\n                time.sleep(self.idle_time)\n        self.is_over = True\n        end = [calc.thread.join() for calc in self.launched]\n        self.join()\n        time.sleep(self.idle_time)\n</code></pre>"},{"location":"dynamicpool/#PoolFlow.dynamic_pool.DynamicPool.display_status","title":"<code>display_status()</code>","text":"<p>Displays the current status of the pool with running jobs, memory allocation, calculation times and job in the queue</p> Source code in <code>PoolFlow\\dynamic_pool.py</code> <pre><code>def display_status(self):\n\"\"\"\n    Displays the current status of the pool with running jobs, memory allocation, calculation times and job in the\n    queue\n    \"\"\"\n    if self.output:\n        with open(self.output, 'w') as out:\n            out.write('')\n    self.csl.print(f'[blue]Pool started - {self.start_date}')\n    self.csl.print(f'[bold red] Threading status - {datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")}')\n    self.csl.print(f'Threads running: {len(self.runnings)}')\n    self.csl.print(f'Threads in queue: {len(self.pool)}')\n    self.csl.print(f'Threads dead: {len(self.deads)}')\n    self.csl.print('[bold blue] Alive threads in pool')\n    table = Table()\n    table.add_column('Thread Id')\n    table.add_column('Cost (Go)')\n    table.add_column('Target')\n    table.add_column('Parameters')\n    table.add_column('Memory Status')\n    table.add_column('Start Date')\n    if self.external:\n        for calc in self.runnings:\n            table.add_row(str(calc.id), str(calc.cost), \"External File\", str(calc.args),\n                          MemoryStatus(calc.counted), calc.start_date)\n    else:\n        for calc in self.runnings:\n            table.add_row(str(calc.id), str(calc.cost), str(calc.target.__name__), str(calc.args),\n                          MemoryStatus(calc.counted), calc.start_date)\n    self.csl.print(table)\n    self.csl.print('[bold pink] Memory status')\n    self.csl.print(f'Total memory: {self.init_memory} Go\\t Available Memory: {self.memory} Go')\n</code></pre>"},{"location":"dynamicpool/#PoolFlow.dynamic_pool.DynamicPool.emit_status","title":"<code>emit_status()</code>","text":"<p>Execute the display_status method every refresh_time with a time stamp</p> Source code in <code>PoolFlow\\dynamic_pool.py</code> <pre><code>@threaded\ndef emit_status(self):\n\"\"\"\n    Execute the display_status method every refresh_time with a time stamp\n    \"\"\"\n    while self.is_alive():\n        self.display_status()\n        sys.stdout.flush()\n        time.sleep(self.refresh_time)\n    self.display_status()\n    self.csl.print(f'[blue]End of pool - {datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")}')\n</code></pre>"},{"location":"dynamicpool/#PoolFlow.dynamic_pool.DynamicPool.review","title":"<code>review(awaiting=False)</code>","text":"<p>Displays a summary of all calculation performed by the pool. It should only be called after when the pool is dead (i.e. after the end function is called).</p> <p>Parameters:</p> Name Type Description Default <code>awaiting</code> <code>bool</code> <p>If True, will wait for the pool to end. (default is False)</p> <code>False</code> Source code in <code>PoolFlow\\dynamic_pool.py</code> <pre><code>@threaded\ndef review(self, awaiting=False):\n\"\"\"\n    Displays a summary of all calculation performed by the pool. It should only be called after when the pool is\n    dead (i.e. after the end function is called).\n\n    Parameters\n    ----------\n    awaiting : bool\n        If True, will wait for the pool to end. (default is False)\n    \"\"\"\n    if awaiting:\n        self.status.join()\n        time.sleep(2 * self.idle_time)\n\n    self.csl.print(f'[bold red]Pool Review', justify=\"center\")\n    self.csl.print(f'[blue]Started - {self.start_date}', justify='center')\n    self.csl.print(f'[blue]Ended - {self.end_date}', justify='center')\n    table = Table()\n    table.add_column('Thread Id')\n    table.add_column('Thread Status')\n    table.add_column('Memory Status')\n    table.add_column('Cost (Go)')\n    table.add_column('Target')\n    table.add_column('Parameters')\n    table.add_column('Start Date')\n    table.add_column('End Date')\n    table.add_column('Running Time (h)')\n    for calc in (self.pool + self.launched):\n        table.add_row(str(calc.id), ThreadStatus(calc.thread.is_alive()), MemoryStatus(calc.counted),\n                      str(calc.cost), str(calc.target.__name__), str(calc.args),\n                      calc.start_date, calc.end_date, RunningTime(calc.start_date, calc.end_date))\n    self.csl.print(table)\n</code></pre>"},{"location":"reference/","title":"A brief principle  of how it works","text":"<pre><code>graph \n  B{&lt;br&gt; \u00a0&lt;br&gt;Pool &lt;br&gt;idle.&lt;br&gt; &lt;br&gt; \u00a0&lt;br&gt; \u00a0};\n  B --&gt;|V.Mem&lt;br&gt;available| A[Allocates V.Mem];\n  A --&gt; C[Launches job];\n  E[Job submited] --&gt;L[Pre-processing];\n  L--&gt;B;\n  Z(User submits&lt;br&gt;jobs continuously) -..-&gt;|Only in dynamic pool| E;\n  B ---&gt;|For every job| F[Job process checking];\n  F ---&gt;|Job is dead| G[Release V.Mem];\n  F ---&gt;|Job is alive| B;\n  G --&gt; K[Post-processing];\n  K --&gt; B;\n  B --&gt;|Emit status| H[Displays current&lt;br&gt;jobs &amp; pool status];\n  B -...-&gt;|Static Pool| R[Terminates when all&lt;br&gt;jobs are done];\n  B -...-&gt;|Dynamic Pool| U[Terminates when *end*&lt;br&gt;method is called];</code></pre>"},{"location":"serverpool/","title":"DynamicPool","text":"<p>         Bases: <code>Thread</code></p> <p>ServerPool is meant to be reached by any other Python terminal using the SumbitToServer function from PoolFlow.utilities. It is currently highly experimental !</p> <p>Examples:</p> <p>Setting up the pool</p> <pre><code>&gt;&gt;&gt; import PoolFlow as pf\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; import time\n&gt;&gt;&gt; pool = pf.ServerPool(override_max_value=20, output='test.log')\n</code></pre> <p>In any other instance:</p> <pre><code>&gt;&gt;&gt; from PoolFlow.utilities import SubmitToServer as smbv\n&gt;&gt;&gt; smbv(('C:\\Users\\Myself\\Documents\\File.py', '1')) #Sumbit file with 1Go cost\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>idle_time</code> <code>int, optional</code> <p>The time in seconds between each verification by the system of the current resources allocations (default is 1)</p> <code>1</code> <code>refresh_time</code> <code>int, optional</code> <p>The time in seconds between each status emission by the pool (default is 5)</p> <code>5</code> <code>override_max_value</code> <code>int or None, optional</code> <p>The maximum virtual memory available in the system/for the pool. If None, will get the maximum from the OS (default is None)</p> <code>None</code> <code>output</code> <code>str or None, optional</code> <p>The file to write the output. If none, will write on the console. (default is None)</p> <code>'/var/log/ServerPool.log'</code> Source code in <code>PoolFlow\\server_pool.py</code> <pre><code>def __init__(self, idle_time=1, refresh_time=5, override_max_value=None, output='/var/log/ServerPool.log'):\n\"\"\"\n    Parameters\n    ----------\n    idle_time : int, optional\n        The time in seconds between each verification by the system of the current resources allocations\n        (default is 1)\n    refresh_time : int, optional\n       The time in seconds between each status emission by the pool (default is 5)\n    override_max_value : int or None, optional\n        The maximum virtual memory available in the system/for the pool. If None, will get the maximum from the OS\n        (default is None)\n    output : str or None, optional\n        The file to write the output. If none, will write on the console. (default is None)\n    \"\"\"\n    super(ServerPool, self).__init__()\n    self.pool = DynamicPool(idle_time, refresh_time, override_max_value, output, external=True)\n    self.pool.start()\n    self.pool.emit_status()\n    self.idle_time = idle_time\n    self.refresh_time = refresh_time\n    self.output = output\n</code></pre>"},{"location":"serverpool/#PoolFlow.server_pool.ServerPool.run","title":"<code>run()</code>","text":"<p>The running function of the pool. Is called by start method  - Not meant to be called by the user -</p> Source code in <code>PoolFlow\\server_pool.py</code> <pre><code>def run(self):\n\"\"\"\n    The running function of the pool. Is called by start method\n     - Not meant to be called by the user -\n    \"\"\"\n    self.__start_server__()\n    while not self.pool.is_over:\n        time.sleep(self.idle_time)\n        for element in self.server.data:\n            if element[1] == True:\n                pass\n            else:\n                args = element[0].split('!@!')\n                if len(args) == 2:\n                    self.pool.submit(None, args[0], int(args[1]))\n                elif len(args) == 4:\n                    self.pool.submit(None, args[0], int(args[1]), args[2], args[3])\n                else:\n                    pass\n                element[1] = True\n</code></pre>"},{"location":"serverpool/#PoolFlow.server_pool.ServerPool.status","title":"<code>status()</code>","text":"<p>Writes the current status in output file</p> Source code in <code>PoolFlow\\server_pool.py</code> <pre><code>def status(self):\n\"\"\"\n    Writes the current status in output file\n    \"\"\"\n    self.pool.output = None\n    self.pool.display_status()\n    self.pool.output = self.output\n</code></pre>"},{"location":"serverpool/#PoolFlow.server_pool.ServerPool.stop","title":"<code>stop()</code>","text":"<p>Ends server</p> Source code in <code>PoolFlow\\server_pool.py</code> <pre><code>def stop(self):\n\"\"\"\n    Ends server\n    \"\"\"\n    self.pool.end(now=True)\n    self.pool.review()\n    self.server.shutdown()\n</code></pre>"},{"location":"staticpool/","title":"StaticPool","text":"<p>         Bases: <code>Thread</code></p> <p>Creates a pool to submit job and manage tasks based on their estimated costs. Jobs are given at the invocation of the instance and ends when all jobs are processed.</p> <p>Attributes:</p> Name Type Description <code>init_memory</code> <code>int</code> <p>Memory available at the creation of the pool. It can be overrided with override_max_value</p> <code>memory</code> <code>int</code> <p>Memory available at the moment</p> <code>output</code> <code>str or None</code> <p>The file to write the output. If none, will write on the console. (default is None)</p> <code>pool</code> <code>list</code> <p>A list of jobs to be executed</p> <code>launched</code> <code>list</code> <p>A list of jobs that have been launched</p> <code>idle_time</code> <code>int</code> <p>The time in seconds between each verification by the system of the current resources allocations (default is 1)</p> <code>refresh_time</code> <code>int</code> <p>The time in seconds between each status emission by the pool (default is 5)</p> <code>is_over</code> <code>bool</code> <p>If True, the pool is terminated</p> <code>count</code> <code>int</code> <p>The number of jobs submitted</p> <code>start_date</code> <code>datetime object</code> <p>The date at which the pool has been created</p> <code>end_date</code> <code>datetime object</code> <p>The date at which the pool has been terminated</p>"},{"location":"staticpool/#PoolFlow.StaticPool--methods","title":"Methods","text":"<p>allocate(calculation)     Virtually allocate an amount of memory based on the calculation cost      - Not meant to be called by the user - release(self, calculation)     Virtually release an amount of memory based on the calculation cost      - Not meant to be called by the user - end(now=False)     Ends the pool and wait for it to be dead run()     The running function of the pool. Is called by start method      - Not meant to be called by the user - display_status()     Displays the current status of the pool with running jobs, memory allocation, calculation times and job in the     queue emit_status()     Execute the display_status method every refresh_time with a time stamp check_status()     A thread that check the current status and health of the pool     - Not meant to be called by the user - review(awaiting=False)     Displays a summary of all calculation performed by the pool. It should only be called after when the pool is     dead (i.e. after the end function is called).</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>function</code> <p>The function containing the jobs to be performed</p> required <code>args</code> <code>list of tuples</code> <p>A list of tuples containing the arguments to be parsed. For instance, if n jobs of the function have to be executed with k arguments for the function, a list of n tuples, each containing k arguments should be given</p> required <code>cost</code> <code>int</code> <p>The cost of each job in giga octets</p> <code>20</code> <code>idle_time</code> <code>int, optional</code> <p>The time in seconds between each verification by the system of the current resources allocations (default is 1)</p> <code>1</code> <code>refresh_time</code> <code>int, optional</code> <p>The time in seconds between each status emission by the pool (default is 5)</p> <code>5</code> <code>override_max_value</code> <code>int or None, optional</code> <p>The maximum virtual memory available in the system/for the pool. If None, will get the maximum from the OS (default is None)</p> <code>None</code> <code>output</code> <code>str or None, optional</code> <p>The file to write the output. If none, will write on the console. (default is None)</p> <code>None</code> Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>def __init__(self, target, args, cost=20, idle_time=1, refresh_time=5, override_max_value=None,\n             output=None):\n\"\"\"\n    Parameters\n    ----------\n    target : function\n        The function containing the jobs to be performed\n    args : list of tuples\n        A list of tuples containing the arguments to be parsed. For instance, if n jobs of the function have to be\n        executed with k arguments for the function, a list of n tuples, each containing k arguments should be given\n    cost : int\n        The cost of each job in giga octets\n    idle_time : int, optional\n        The time in seconds between each verification by the system of the current resources allocations\n        (default is 1)\n    refresh_time : int, optional\n       The time in seconds between each status emission by the pool (default is 5)\n    override_max_value : int or None, optional\n        The maximum virtual memory available in the system/for the pool. If None, will get the maximum from the OS\n        (default is None)\n    output : str or None, optional\n        The file to write the output. If none, will write on the console. (default is None)\n    \"\"\"\n    super(StaticPool, self).__init__()\n    self.status = None\n    if not override_max_value:\n        self.init_memory = round(mem().available / 1E9, 0)\n    else:\n        self.init_memory = override_max_value\n    self.output = output\n    self.memory = self.init_memory\n    self.cost = cost\n    self.args = args\n    self.threads = []\n    self.idle_time = idle_time\n    self.refresh_time = refresh_time\n    self.len = len(args)\n    self.where = 0\n    self.target = target\n    self.is_over = False\n    self.start_date = datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")\n    self.end_date = \"\"\n    self.pool = []\n    self.launched = []\n    self.count = 0\n    for arg in self.args:\n        self.count += 1\n        self.pool.append(Calculation(target, arg, self.cost, self.count))\n    if self.output:\n        self.csl = Console(file=open(self.output, 'w'))\n    else:\n        self.csl = Console()\n</code></pre>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.runnings","title":"<code>runnings</code>  <code>property</code>","text":"<p>Returns a list with running jobs - Not meant to be called by the user -</p>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.deads","title":"<code>deads</code>  <code>property</code>","text":"<p>Returns a list of dead jobs - Not meant to be called by the user -</p>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.allocate","title":"<code>allocate(calc)</code>","text":"<p>Virtually allocate an amount of memory based on the calculation cost  - Not meant to be called by the user -</p> <p>Parameters:</p> Name Type Description Default <code>calc</code> <code>a Calculation object</code> required Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>def allocate(self, calc):\n\"\"\"\n    Virtually allocate an amount of memory based on the calculation cost\n     - Not meant to be called by the user -\n\n    Parameters\n    ----------\n    calc : a Calculation object\n    \"\"\"\n    self.memory += -calc.cost\n</code></pre>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.release","title":"<code>release(calc)</code>","text":"<p>Virtually release an amount of memory based on the calculation cost  - Not meant to be called by the user -</p> <p>Parameters:</p> Name Type Description Default <code>calc</code> <code>a Calculation object</code> required Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>def release(self, calc):\n\"\"\"\n    Virtually release an amount of memory based on the calculation cost\n     - Not meant to be called by the user -\n\n    Parameters\n    ----------\n    calc : a Calculation object\n    \"\"\"\n    self.memory += calc.cost\n</code></pre>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.run","title":"<code>run()</code>","text":"<p>The running function of the pool. Is called by start method  - Not meant to be called by the user -</p> Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>def run(self):\n\"\"\"\n    The running function of the pool. Is called by start method\n     - Not meant to be called by the user -\n    \"\"\"\n    self.status = self.check_status()\n    while not self.is_over:\n        for calc in self.pool:\n            if self.memory &gt; calc.cost and calc.ispreprocessed:\n                self.allocate(calc)\n                self.launched.append(calc)\n                self.pool.remove(calc)\n                self.launched[-1].start()\n            elif not calc.ispreprocessed:\n                calc.launch_pre_processing()\n            else:\n                pass\n        for calc in self.launched:\n            if not calc.isrunning and calc.isdead and not calc.ispostprocessed:\n                calc.launch_post_processing()\n            else:\n                pass\n        time.sleep(self.idle_time)\n</code></pre>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.display_status","title":"<code>display_status()</code>","text":"<p>Displays the current status of the pool with running jobs, memory allocation, calculation times and job in the queue</p> Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>def display_status(self):\n\"\"\"\n    Displays the current status of the pool with running jobs, memory allocation, calculation times and job in the\n    queue\n    \"\"\"\n    if self.output:\n        with open(self.output, 'w') as out:\n            out.write('')\n    self.csl.print(f'[blue]Pool started - {self.start_date}')\n    self.csl.print(f'[bold red] Threading status - {datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")}')\n    self.csl.print(f'Threads running: {len(self.runnings)}')\n    self.csl.print(f'Threads in queue: {len(self.pool)}')\n    self.csl.print(f'Threads dead: {len(self.deads)}')\n    self.csl.print('[bold blue] Alive threads in pool')\n    table = Table()\n    table.add_column('Thread Id')\n    table.add_column('Cost (Go)')\n    table.add_column('Target')\n    table.add_column('Parameters')\n    table.add_column('Memory Status')\n    table.add_column('Start Date')\n    for calc in self.runnings:\n        table.add_row(str(calc.id), str(calc.cost), str(calc.target.__name__), str(calc.args),\n                      MemoryStatus(calc.counted), calc.start_date)\n    self.csl.print(table)\n    self.csl.print('[bold pink] Memory status')\n    self.csl.print(f'Total memory: {self.init_memory} Go\\t Available Memory: {self.memory} Go')\n</code></pre>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.emit_status","title":"<code>emit_status()</code>","text":"<p>Execute the display_status method every refresh_time with a time stamp</p> Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>@threaded\ndef emit_status(self):\n\"\"\"\n    Execute the display_status method every refresh_time with a time stamp\n    \"\"\"\n    while self.is_alive():\n        self.display_status()\n        sys.stdout.flush()\n        time.sleep(self.refresh_time)\n    self.display_status()\n    self.csl.print(f'[blue]End of pool - {datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")}')\n</code></pre>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.check_status","title":"<code>check_status()</code>","text":"<p>A thread that check the current status and health of the pool - Not meant to be called by the user -</p> Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>@threaded\ndef check_status(self):\n\"\"\"\n    A thread that check the current status and health of the pool\n    - Not meant to be called by the user -\n    \"\"\"\n    while not self.is_over:\n        for calc in self.launched:\n            if not calc.thread.is_alive() and not calc.counted and calc.isrunning:\n                self.release(calc)\n                calc.end_date = datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")\n                calc.isrunning = False\n                calc.isdead = True\n                calc.counted = True\n            elif self.pool == [] and self.runnings == [] and len(self.deads) == self.count:\n                self.is_over = True\n            else:\n                pass\n        time.sleep(self.idle_time)\n\n    self.end_date = datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")\n</code></pre>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.review","title":"<code>review(awaiting=False)</code>","text":"<p>Displays a summary of all calculation performed by the pool. It should only be called after when the pool is dead (i.e. after the end function is called).</p> <p>Parameters:</p> Name Type Description Default <code>awaiting</code> <code>bool</code> <p>If True, will wait for the pool to end. (default is False)</p> <code>False</code> Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>@threaded\ndef review(self, awaiting=False):\n\"\"\"\n    Displays a summary of all calculation performed by the pool. It should only be called after when the pool is\n    dead (i.e. after the end function is called).\n\n    Parameters\n    ----------\n    awaiting : bool\n        If True, will wait for the pool to end. (default is False)\n    \"\"\"\n    if awaiting:\n        self.status.join()\n        time.sleep(3 * self.idle_time)\n\n    self.csl.print(f'[bold red]Pool Review', justify=\"center\")\n    self.csl.print(f'[blue]Started - {self.start_date}', justify='center')\n    self.csl.print(f'[blue]Ended - {self.end_date}', justify='center')\n    table = Table()\n    table.add_column('Thread Id')\n    table.add_column('Thread Status')\n    table.add_column('Memory Status')\n    table.add_column('Cost (Go)')\n    table.add_column('Target')\n    table.add_column('Parameters')\n    table.add_column('Start Date')\n    table.add_column('End Date')\n    table.add_column('Running Time (h)')\n    for calc in (self.pool + self.launched):\n        table.add_row(str(calc.id), ThreadStatus(calc.thread.is_alive()), MemoryStatus(calc.counted),\n                      str(calc.cost), str(calc.target.__name__), str(calc.args),\n                      calc.start_date, calc.end_date, RunningTime(calc.start_date, calc.end_date))\n    self.csl.print(table)\n</code></pre>"},{"location":"staticpool/#PoolFlow.static_pool.StaticPool.end","title":"<code>end(now=False)</code>","text":"<p>Ends the pool and wait for it to be dead.</p> <p>Parameters:</p> Name Type Description Default <code>now</code> <code>bool, optional</code> <p>If True, forces the jobs to end (default is False)</p> <code>False</code> Source code in <code>PoolFlow\\static_pool.py</code> <pre><code>def end(self, now=False):\n\"\"\"\n    Ends the pool and wait for it to be dead.\n\n    Parameters\n    ----------\n    now : bool, optional\n        If True, forces the jobs to end (default is False)\n    \"\"\"\n    if now:\n        if not self.pool:\n            self.csl.print('[red]Cannot end pool - Threads are still awaiting. Force with empty method')\n    else:\n        if not now:\n            while self.pool or self.runnings:\n                time.sleep(self.idle_time)\n        self.is_over = True\n        end = [calc.thread.join() for calc in self.launched]\n        self.join()\n        time.sleep(self.idle_time)\n</code></pre>"},{"location":"tutorials/","title":"First steps and examples","text":""},{"location":"utilities/","title":"Utilities","text":""},{"location":"utilities/#PoolFlow.utilities.pool_utilities.Calculation","title":"<code>Calculation(target, args, cost, id, pre_processing=None, post_processing=None)</code>","text":"<p>An object to launch the jobs, check their status and manage pre and post processing Calculation instances are directly created and managed by pool - Not meant to be called by users -</p> <p>Attributes:</p> Name Type Description <code>target</code> <code>function</code> <p>The function containing the job</p> <code>args</code> <code>tuple</code> <p>The arguments of the function to be performed</p> <code>cost</code> <code>int</code> <p>The cost of each job in giga octets</p> <code>id</code> <code>int</code> <p>The id of the job. Directly managed by the pool.</p> <code>pre_processing</code> <code>tuple or None</code> <p>The pre-processing function and its argument to be executed in the form of (function, (tuple,with,arguments)). (default is None)</p> <code>post_processing</code> <code>tuple or None</code> <p>The post-processing function and its argument to be executed in the form of (function, (tuple,with,arguments)). (default is None)</p> <code>counted</code> <code>bool</code> <p>An internal flag for pools to manage if Calculation object has been recorded as done</p> <code>start_date</code> <code>datetime object</code> <p>The date at which the job has been launched</p> <code>end_date</code> <code>datetime object</code> <p>The date at which the job has been ended</p> <code>is_done</code> <code>bool</code> <p>An internal flag for pools to manage if Calculation object has been done</p> <code>isdead</code> <code>bool</code> <p>An internal flag for pools to manage if job is dead</p> <code>ispostprocessed</code> <code>bool</code> <p>An internal flag for pools to manage if post-processing has been executed</p> <code>isppreprocessed</code> <code>bool</code> <p>An internal flag for pools to manage if pre-processing has been executed</p> <code>isrunning</code> <code>bool</code> <p>An internal flag for pools to manage if job is running</p> <code>running_time</code> <code>datetime</code> <p>The time the job has been running</p> <code>thread</code> <code>Thread</code> <p>The thread containing the job</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>function</code> <p>The function containing the job</p> required <code>args</code> <code>tuple</code> <p>The arguments of the function to be performed</p> required <code>cost</code> <code>int</code> <p>The cost of each job in giga octets</p> required <code>id</code> <code>int</code> <p>The id of the job. Directly managed by the pool.</p> required <code>pre_processing</code> <code>tuple or None, optional</code> <p>The pre-processing function and its argument to be executed in the form of (function, (tuple,with,arguments)). (default is None)</p> <code>None</code> <code>post_processing</code> <code>tuple or None, optional</code> <p>The post-processing function and its argument to be executed in the form of (function, (tuple,with,arguments)). (default is None)</p> <code>None</code> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def __init__(self, target, args, cost, id, pre_processing=None, post_processing=None):\n\"\"\"\n    Parameters\n    ----------\n    target : function\n        The function containing the job\n    args : tuple\n        The arguments of the function to be performed\n    cost : int\n        The cost of each job in giga octets\n    id : int\n        The id of the job. Directly managed by the pool.\n    pre_processing : tuple or None, optional\n        The pre-processing function and its argument to be executed in the form of\n        (function, (tuple,with,arguments)). (default is None)\n    post_processing : tuple or None, optional\n        The post-processing function and its argument to be executed in the form of\n        (function, (tuple,with,arguments)). (default is None)\n    \"\"\"\n    self.target = target\n    self.args = args\n    self.id = id\n    self.cost = cost\n    self.is_done = False\n    self.thread = (Thread(target=self.target, args=self.args))\n    self.counted = False\n    self.start_date = '/'\n    self.end_date = '/'\n    self.running_time = '/'\n    self.isrunning = False\n    self.isdead = False\n    self.pre_processing = pre_processing\n    self.ispreprocessed = False\n    self.post_processing = post_processing\n    self.ispostprocessed = False\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.Calculation.start","title":"<code>start()</code>","text":"<p>Launches the calculation</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def start(self):\n\"\"\"\n    Launches the calculation\n    \"\"\"\n    self.thread.start()\n    self.start_date = datetime.datetime.now().strftime(\"%d/%m/%y-%H:%M:%S\")\n    self.isrunning = True\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.Calculation.launch_pre_processing","title":"<code>launch_pre_processing()</code>","text":"<p>Launches the pre-processing and flag it as performed</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>@threaded\ndef launch_pre_processing(self):\n\"\"\"\n    Launches the pre-processing and flag it as performed\n    \"\"\"\n    if self.pre_processing:\n        th = Thread(target=self.pre_processing[0], args=self.pre_processing[1])\n        th.start()\n        th.join()\n    else:\n        pass\n    self.ispreprocessed = True\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.Calculation.launch_post_processing","title":"<code>launch_post_processing()</code>","text":"<p>Launches the post-processing and flag it as performed</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>@threaded\ndef launch_post_processing(self):\n\"\"\"\n    Launches the post-processing and flag it as performed\n    \"\"\"\n    if self.post_processing:\n        th = Thread(target=self.post_processing[0], args=self.post_processing[1])\n        th.start()\n        th.join()\n    else:\n        pass\n    self.ispostprocessed = True\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.LimitedProcess","title":"<code>LimitedProcess(command, limit, ishard=False)</code>","text":"<p>An object to use inside the creation of job functions to limit the usage of virtual memory when using a command Only available on Unix platforms</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The command to execute as it would be written in a command line</p> <code>limit</code> <code>int</code> <p>The memory limit to use in giga octets</p> <code>ishard</code> <code>bool</code> <p>If True, the limit would not be exceeded even if the job is to crash because of memory limit</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The command to execute as it would be written in a command line</p> required <code>limit</code> <code>int</code> <p>The memory limit to use in giga octets</p> required <code>ishard</code> <code>bool, optional</code> <p>If True, the limit would not be exceeded even if the job is to crash because of memory limit</p> <code>False</code> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def __init__(self, command, limit, ishard=False):\n\"\"\"\n    Parameters\n    ----------\n    command : str\n        The command to execute as it would be written in a command line\n    limit : int\n        The memory limit to use in giga octets\n    ishard : bool, optional\n        If True, the limit would not be exceeded even if the job is to crash because of memory limit\n    \"\"\"\n    self.command = command\n    self.limit = limit * 1E3 * 1024 * 1024\n    self.ishard = ishard\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.LimitedProcess.launch","title":"<code>launch()</code>","text":"<p>Launches the command with the given limits</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def launch(self):\n\"\"\"\n    Launches the command with the given limits\n    \"\"\"\n    if os.name == 'posix':\n        subprocess.run(shlex.split(self.command), preexec_fn=self.limit_virtual_memory)\n    else:\n        subprocess.run(shlex.split(self.command))\n        warnings.warn(f'Platform {os.name} does not support resources limitations')\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.LimitedProcess.limit_virtual_memory","title":"<code>limit_virtual_memory()</code>","text":"<p>The limiter function</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def limit_virtual_memory(self):\n\"\"\"\n    The limiter function\n    \"\"\"\n    if os.name == 'posix':\n        if self.ishard:\n            resource.setrlimit(resource.RLIMIT_AS, (self.limit, resource.RLIM_INFINITY))\n        else:\n            resource.setrlimit(resource.RLIMIT_AS, (self.limit, self.limit))\n    else:\n        warnings.warn(f'Platform {os.name} does not support resources limitations')\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.UnlimitedProcess","title":"<code>UnlimitedProcess(command)</code>","text":"<p>An object to use inside the creation of job functions to set no limit to the usage of virtual memory when using a command Only available on Unix platforms</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The command to execute as it would be written in a command line</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def __init__(self, command):\n    self.command = command\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.UnlimitedProcess.launch","title":"<code>launch()</code>","text":"<p>Launches the command with the given limits</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def launch(self):\n\"\"\"\n    Launches the command with the given limits\n    \"\"\"\n    if os.name == 'posix':\n        subprocess.run(shlex.split(self.command), preexec_fn=self.limit_virtual_memory)\n    else:\n        subprocess.run(shlex.split(self.command))\n        warnings.warn(f'Platform {os.name} does not support resources limitations')\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.UnlimitedProcess.limit_virtual_memory","title":"<code>limit_virtual_memory()</code>  <code>staticmethod</code>","text":"<p>The limiter function</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>@staticmethod\ndef limit_virtual_memory():\n\"\"\"\n    The limiter function\n    \"\"\"\n    if os.name == 'posix':\n        resource.setrlimit(resource.RLIMIT_AS, (-1, -1))\n    else:\n        warnings.warn(f'Platform {os.name} does not support resources limitations')\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.TCPHandler","title":"<code>TCPHandler</code>","text":"<p>         Bases: <code>socketserver.StreamRequestHandler</code></p> <p>The request handler class for our server.</p> <p>It is instantiated once per connection to the server, and must override the handle() method to implement communication to the client.</p>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.SubmitToServer","title":"<code>SubmitToServer(data, HOST='localhost', PORT=7455)</code>","text":"<p>Submit a calculation to the local pool server</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from PoolFlow.utilities import SubmitToServer as smbv\n&gt;&gt;&gt; smbv(('C:\\Users\\Myself\\Documents\\File.py', '1')) #Sumbit file with 1Go cost\n</code></pre> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def SubmitToServer(data, HOST='localhost', PORT=7455):\n\"\"\"\n    Submit a calculation to the local pool server\n\n    Examples\n    --------\n    &gt;&gt;&gt; from PoolFlow.utilities import SubmitToServer as smbv\n    &gt;&gt;&gt; smbv(('C:\\\\Users\\\\Myself\\\\Documents\\\\File.py', '1')) #Sumbit file with 1Go cost\n    \"\"\"\n    data = '!@!'.join(data)\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:\n        sock.connect((HOST, PORT))\n        sock.sendall(bytes(data + \"\\n\", \"utf-8\"))\n</code></pre>"},{"location":"utilities/#PoolFlow.utilities.pool_utilities.RawExternalCmd","title":"<code>RawExternalCmd(file)</code>","text":"<p>Used by DynamicPool for ServerPool instance purposes</p> Source code in <code>PoolFlow\\utilities\\pool_utilities.py</code> <pre><code>def RawExternalCmd(file):\n\"\"\"\n    Used by DynamicPool for ServerPool instance purposes\n    \"\"\"\n    return subprocess.run(['python', file])\n</code></pre>"}]}